<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>é¡”ã«èŠ‹ã‚’è²¼ã‚‹AI</title>
<style>
  body, main {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    background: #f4f4f4;
  }
  body {
    min-height: 95vh;
    display: flex;
    flex-direction: column;
  }
  main {
    flex: 1;
    padding: 2rem;
  }
  canvas {
    border: 1px solid #aaa;
    border-radius: 8px;
    max-width: 90vw;
    cursor: grab;
  }
  #controls {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    justify-content: center;
  }
  button {
    padding: 0.6rem 1.2rem;
    font-size: 1rem;
    border: none;
    border-radius: 6px;
    background: #0078d7;
    color: white;
    cursor: pointer;
  }
  button:disabled {
    background: #999;
    cursor: not-allowed;
  }
  .loader {
    width: 50px;
    aspect-ratio: 1;
    border-radius: 50%;
    border: 8px solid;
    border-color: #000 #0000;
    animation: l1 1s infinite;
  }
  @keyframes l1 {to{transform: rotate(.5turn)}}
</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
<link rel="icon" href="imo.png" type="image/png">
</head>
<body>
  <main>
    <h2>é¡”ã«èŠ‹ã‚’è²¼ã‚Šä»˜ã‘ã‚ˆã†</h2>
    <div class="loader"></div>
    <p2 class="loadText">ãƒ¢ãƒ‡ãƒ«ãƒ­ãƒ¼ãƒ‰ä¸­</p2>
    
    <input type="file" id="fileInput" accept="image/*">
    <canvas id="canvas" style="max-height:90vh;"></canvas>

    <div id="controls">
      <button id="processBtn" disabled>é¡”æ¤œå‡ºï¼‹è²¼ã‚Šä»˜ã‘</button>
      <button id="addBtn" disabled>èŠ‹ã‚’è¿½åŠ </button>
      <button id="deleteBtn" disabled>é¸æŠå‰Šé™¤</button>
      <button id="downloadBtn" disabled>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
    </div>
    <!-- æ“ä½œèª¬æ˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
    <section id="instructions" style="max-width: 600px; background: #fff; padding: 1rem 1.5rem; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); line-height: 1.6;">
      <h3 style="margin-top: 0; text-align: center;">ğŸ“ æ“ä½œèª¬æ˜</h3>
      <ul style="padding-left: 1.2rem; list-style-type: 'ğŸ’¡ ';">
        <li>ç”»åƒã‚’é¸æŠã™ã‚‹ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
        <li><b>ã€Œé¡”æ¤œå‡ºï¼‹è²¼ã‚Šä»˜ã‘ã€</b>ã‚’æŠ¼ã™ã¨ã€è‡ªå‹•ã§é¡”ã«èŠ‹ãŒé…ç½®ã•ã‚Œã¾ã™ã€‚</li>
        <li>æ¤œå‡ºå¾Œã€å„èŠ‹ã‚’æ¬¡ã®æ“ä½œã§ç·¨é›†ã§ãã¾ã™ï¼š</li>
        <ul style="padding-left: 1.5rem; list-style-type: 'ğŸ‘‰ ';">
          <li><b>ã‚¯ãƒªãƒƒã‚¯</b>ã§é¸æŠ</li>
          <li><b>ãƒ‰ãƒ©ãƒƒã‚°</b>ã§ä½ç½®ç§»å‹•</li>
          <li><b>ç«¯ã‚’ãƒ‰ãƒ©ãƒƒã‚°</b>ã§ã‚µã‚¤ã‚ºå¤‰æ›´</li>
          <li><b>Shift+ä¸­å¤®ä»˜è¿‘ã‚’ãƒ‰ãƒ©ãƒƒã‚°</b>ã§å›è»¢</li>
          <li><b>ã€Œé¸æŠå‰Šé™¤ã€ãƒœã‚¿ãƒ³</b>ã§é¸æŠã—ãŸèŠ‹ã‚’å‰Šé™¤</li>
          <li><b>ã€ŒèŠ‹ã‚’è¿½åŠ ã€ãƒœã‚¿ãƒ³</b>ã§æ–°ãŸã«èŠ‹ã‚’è¿½åŠ </li>
        </ul>
        <li>ç·¨é›†ã¯<b>ã‚¹ãƒãƒ›ã§ã¯ä¸€éƒ¨å¯¾å¿œã—ã¦ã„ãªã„æ“ä½œ</b>ãŒã‚ã‚Šã¾ã™ã€‚</li>
        <li>èª¿æ•´ãŒçµ‚ã‚ã£ãŸã‚‰ã€<b>ã€Œãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€</b>ã§ä¿å­˜ã§ãã¾ã™ã€‚</li>
      </ul>
    </section>
  </main>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const fileInput = document.getElementById("fileInput");
    const processBtn = document.getElementById("processBtn");
    const addBtn = document.getElementById("addBtn");
    const deleteBtn = document.getElementById("deleteBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const loadingCss = document.getElementsByClassName("loader")[0];
    const loadingText = document.getElementsByClassName("loadText")[0];

    let image = new Image();
    let model, overlayImage;
    let overlays = []; // â† å…¨overlayæƒ…å ±ã‚’æ ¼ç´
    let selectedIndex = null;
    let dragging = false;
    let rotating = false;
    let resizing = false;
    let lastMouse = { x: 0, y: 0 };

    async function init() {
      model = await blazeface.load();
      overlayImage = await loadOverlayImage("imo.png");
      loadingCss.style = "display:none;";
      loadingText.style = "display:none;";
    }

    async function loadOverlayImage(url) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      return new Promise((resolve, reject) => {
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    fileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => { image.src = reader.result; };
      reader.readAsDataURL(file);
    });

    image.onload = () => {
      canvas.width = image.width;
      canvas.height = image.height;
      ctx.drawImage(image, 0, 0);
      processBtn.disabled = false;
    };

    processBtn.addEventListener("click", async () => {
      if (!model) return;
      loadingCss.style = "";
      loadingText.style = "";
      loadingText.innerHTML = "é¡”æ¤œå‡ºä¸­â€¦";

      const preds = await model.estimateFaces(image, false);
      overlays = preds.map(pred => {
        const [x1, y1] = pred.topLeft;
        const [x2, y2] = pred.bottomRight;
        const w = x2 - x1;
        const h = y2 - y1;
        const cx = x1 + w / 2;
        const cy = y1 + h / 2;
        const W_PAD = 0.3, H_PAD = 0.4;
        const ww = w * (1 + W_PAD);
        const hh = h * (1 + H_PAD);
        let angle = 0;
        if (pred.landmarks?.length >= 2) {
          const [l, r] = pred.landmarks;
          angle = Math.atan2(r[1] - l[1], r[0] - l[0]);
        }
        return { x: cx, y: cy, w: ww, h: hh, angle };
      });

      redraw();
      loadingCss.style = "display:none;";
      loadingText.style = "display:none;";
      addBtn.disabled = false;
      deleteBtn.disabled = false;
      downloadBtn.disabled = false;
    });

    addBtn.addEventListener("click", () => {
      overlays.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        w: 200,
        h: 200,
        angle: 0
      });
      redraw();
    });

    deleteBtn.addEventListener("click", () => {
      if (selectedIndex !== null) {
        overlays.splice(selectedIndex, 1);
        selectedIndex = null;
        redraw();
      }
    });

    downloadBtn.addEventListener("click", () => {
      const a = document.createElement("a");
      a.href = renderFinalImage();
      a.download = "processed.png";
      a.click();
    });

    // ====== æç”»é–¢é€£ ======
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);
      overlays.forEach((o, i) => drawOverlay(o, i === selectedIndex));
    }

    function drawOverlay(o, selected=false) {
      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.rotate(o.angle);
      ctx.drawImage(overlayImage, -o.w/2, -o.h/2, o.w, o.h);
      if (selected) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 3;
        ctx.strokeRect(-o.w/2, -o.h/2, o.w, o.h);
      }
      ctx.restore();
    }

    // ====== ãƒã‚¦ã‚¹æ“ä½œ ======
    canvas.addEventListener("mousedown", e => {
      const mouse = getMousePos(e);
      selectedIndex = findOverlayAt(mouse.x, mouse.y);
      if (selectedIndex !== null) {
        const o = overlays[selectedIndex];
        const dx = mouse.x - o.x;
        const dy = mouse.y - o.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const edge = Math.max(o.w, o.h) / 2;
        if (Math.abs(dist - edge) < 20) resizing = true;
        else if (e.shiftKey) rotating = true;
        else dragging = true;
      }
      lastMouse = mouse;
      redraw();
    });

    canvas.addEventListener("mousemove", e => {
      if (selectedIndex === null) return;
      const mouse = getMousePos(e);
      const o = overlays[selectedIndex];
      const dx = mouse.x - lastMouse.x;
      const dy = mouse.y - lastMouse.y;

      if (dragging) {
        o.x += dx;
        o.y += dy;
      } else if (rotating) {
        const a1 = Math.atan2(lastMouse.y - o.y, lastMouse.x - o.x);
        const a2 = Math.atan2(mouse.y - o.y, mouse.x - o.x);
        o.angle += a2 - a1;
      } else if (resizing) {
        o.w += dx;
        o.h += dy;
      }

      lastMouse = mouse;
      redraw();
    });

    canvas.addEventListener("mouseup", () => {
      dragging = rotating = resizing = false;
    });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    function findOverlayAt(x, y) {
      for (let i = overlays.length - 1; i >= 0; i--) {
        const o = overlays[i];
        const dx = x - o.x;
        const dy = y - o.y;
        const r = Math.sqrt(dx*dx + dy*dy);
        if (r < Math.max(o.w, o.h)/2) return i;
      }
      return null;
    }

    // ====== æœ€çµ‚å‡ºåŠ› ======
    function renderFinalImage() {
      const tmp = document.createElement("canvas");
      tmp.width = canvas.width;
      tmp.height = canvas.height;
      const tctx = tmp.getContext("2d");
      tctx.drawImage(image, 0, 0);
      overlays.forEach(o => {
        tctx.save();
        tctx.translate(o.x, o.y);
        tctx.rotate(o.angle);
        tctx.drawImage(overlayImage, -o.w/2, -o.h/2, o.w, o.h);
        tctx.restore();
      });
      return tmp.toDataURL("image/png");
    }

    window.onload = init;
  </script>

  <footer style="width:100%;">
    <hr>
    <p style="text-align:center;color:#777;">
      Â© 2025 PotatoTimeKun<br>
      å¸¸è­˜ã®ç¯„å›²å†…ã§ãŠä½¿ã„ãã ã•ã„ã€‚<br>
      MIT Licence
    </p>
  </footer>
</body>
</html>
