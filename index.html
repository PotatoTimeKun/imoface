<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>顔に芋を貼るAI</title>
<style>
  body, main {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    background: #f4f4f4;
  }
  body {
    min-height: 95vh;
    display: flex;
    flex-direction: column;
  }
  main {
    flex: 1;
    padding: 2rem;
  }
  canvas {
    border: 1px solid #aaa;
    border-radius: 8px;
    max-width: 90vw;
    cursor: grab;
  }
  #controls {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    justify-content: center;
  }
  button {
    padding: 0.6rem 1.2rem;
    font-size: 1rem;
    border: none;
    border-radius: 6px;
    background: #0078d7;
    color: white;
    cursor: pointer;
  }
  button:disabled {
    background: #999;
    cursor: not-allowed;
  }
  .loader {
    width: 50px;
    aspect-ratio: 1;
    border-radius: 50%;
    border: 8px solid;
    border-color: #000 #0000;
    animation: l1 1s infinite;
  }
  @keyframes l1 {to{transform: rotate(.5turn)}}
</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
<link rel="icon" href="imo.png" type="image/png">
</head>
<body>
  <main>
    <h2>顔に芋を貼り付けよう</h2>
    <div class="loader"></div>
    <p2 class="loadText">モデルロード中</p2>
    
    <input type="file" id="fileInput" accept="image/*">
    <canvas id="canvas" style="max-height:90vh;"></canvas>

    <div id="controls">
      <button id="processBtn" disabled>顔検出＋貼り付け</button>
      <button id="addBtn" disabled>芋を追加</button>
      <button id="deleteBtn" disabled>選択削除</button>
      <button id="downloadBtn" disabled>ダウンロード</button>
    </div>
    <!-- 操作説明セクション -->
    <section id="instructions" style="max-width: 600px; background: #fff; padding: 1rem 1.5rem; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); line-height: 1.6;">
      <h3 style="margin-top: 0; text-align: center;">📝 操作説明</h3>
      <ul style="padding-left: 1.2rem; list-style-type: '💡 ';">
        <li>画像を選択するとキャンバスに表示されます。</li>
        <li><b>「顔検出＋貼り付け」</b>を押すと、自動で顔に芋が配置されます。</li>
        <li>検出後、各芋を次の操作で編集できます：</li>
        <ul style="padding-left: 1.5rem; list-style-type: '👉 ';">
          <li><b>クリック</b>で選択</li>
          <li><b>ドラッグ</b>で位置移動</li>
          <li><b>端をドラッグ</b>でサイズ変更</li>
          <li><b>Shift+中央付近をドラッグ</b>で回転</li>
          <li><b>「選択削除」ボタン</b>で選択した芋を削除</li>
          <li><b>「芋を追加」ボタン</b>で新たに芋を追加</li>
        </ul>
        <li>編集は<b>スマホでは一部対応していない操作</b>があります。</li>
        <li>調整が終わったら、<b>「ダウンロード」</b>で保存できます。</li>
      </ul>
    </section>
  </main>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const fileInput = document.getElementById("fileInput");
    const processBtn = document.getElementById("processBtn");
    const addBtn = document.getElementById("addBtn");
    const deleteBtn = document.getElementById("deleteBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const loadingCss = document.getElementsByClassName("loader")[0];
    const loadingText = document.getElementsByClassName("loadText")[0];

    let image = new Image();
    let model, overlayImage;
    let overlays = []; // ← 全overlay情報を格納
    let selectedIndex = null;
    let dragging = false;
    let rotating = false;
    let resizing = false;
    let lastMouse = { x: 0, y: 0 };

    async function init() {
      model = await blazeface.load();
      overlayImage = await loadOverlayImage("imo.png");
      loadingCss.style = "display:none;";
      loadingText.style = "display:none;";
    }

    async function loadOverlayImage(url) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      return new Promise((resolve, reject) => {
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    fileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => { image.src = reader.result; };
      reader.readAsDataURL(file);
    });

    image.onload = () => {
      canvas.width = image.width;
      canvas.height = image.height;
      ctx.drawImage(image, 0, 0);
      processBtn.disabled = false;
    };

    processBtn.addEventListener("click", async () => {
      if (!model) return;
      loadingCss.style = "";
      loadingText.style = "";
      loadingText.innerHTML = "顔検出中…";

      const preds = await model.estimateFaces(image, false);
      overlays = preds.map(pred => {
        const [x1, y1] = pred.topLeft;
        const [x2, y2] = pred.bottomRight;
        const w = x2 - x1;
        const h = y2 - y1;
        const cx = x1 + w / 2;
        const cy = y1 + h / 2;
        const W_PAD = 0.3, H_PAD = 0.4;
        const ww = w * (1 + W_PAD);
        const hh = h * (1 + H_PAD);
        let angle = 0;
        if (pred.landmarks?.length >= 2) {
          const [l, r] = pred.landmarks;
          angle = Math.atan2(r[1] - l[1], r[0] - l[0]);
        }
        return { x: cx, y: cy, w: ww, h: hh, angle };
      });

      redraw();
      loadingCss.style = "display:none;";
      loadingText.style = "display:none;";
      addBtn.disabled = false;
      deleteBtn.disabled = false;
      downloadBtn.disabled = false;
    });

    addBtn.addEventListener("click", () => {
      overlays.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        w: 200,
        h: 200,
        angle: 0
      });
      redraw();
    });

    deleteBtn.addEventListener("click", () => {
      if (selectedIndex !== null) {
        overlays.splice(selectedIndex, 1);
        selectedIndex = null;
        redraw();
      }
    });

    downloadBtn.addEventListener("click", () => {
      const a = document.createElement("a");
      a.href = renderFinalImage();
      a.download = "processed.png";
      a.click();
    });

    // ====== 描画関連 ======
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);
      overlays.forEach((o, i) => drawOverlay(o, i === selectedIndex));
    }

    function drawOverlay(o, selected=false) {
      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.rotate(o.angle);
      ctx.drawImage(overlayImage, -o.w/2, -o.h/2, o.w, o.h);
      if (selected) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 3;
        ctx.strokeRect(-o.w/2, -o.h/2, o.w, o.h);
      }
      ctx.restore();
    }

    // ====== マウス操作 ======
    canvas.addEventListener("mousedown", e => {
      const mouse = getMousePos(e);
      selectedIndex = findOverlayAt(mouse.x, mouse.y);
      if (selectedIndex !== null) {
        const o = overlays[selectedIndex];
        const dx = mouse.x - o.x;
        const dy = mouse.y - o.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const edge = Math.max(o.w, o.h) / 2;
        if (Math.abs(dist - edge) < 20) resizing = true;
        else if (e.shiftKey) rotating = true;
        else dragging = true;
      }
      lastMouse = mouse;
      redraw();
    });

    canvas.addEventListener("mousemove", e => {
      if (selectedIndex === null) return;
      const mouse = getMousePos(e);
      const o = overlays[selectedIndex];
      const dx = mouse.x - lastMouse.x;
      const dy = mouse.y - lastMouse.y;

      if (dragging) {
        o.x += dx;
        o.y += dy;
      } else if (rotating) {
        const a1 = Math.atan2(lastMouse.y - o.y, lastMouse.x - o.x);
        const a2 = Math.atan2(mouse.y - o.y, mouse.x - o.x);
        o.angle += a2 - a1;
      } else if (resizing) {
        o.w += dx;
        o.h += dy;
      }

      lastMouse = mouse;
      redraw();
    });

    canvas.addEventListener("mouseup", () => {
      dragging = rotating = resizing = false;
    });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    function findOverlayAt(x, y) {
      for (let i = overlays.length - 1; i >= 0; i--) {
        const o = overlays[i];
        const dx = x - o.x;
        const dy = y - o.y;
        const r = Math.sqrt(dx*dx + dy*dy);
        if (r < Math.max(o.w, o.h)/2) return i;
      }
      return null;
    }

    // ====== 最終出力 ======
    function renderFinalImage() {
      const tmp = document.createElement("canvas");
      tmp.width = canvas.width;
      tmp.height = canvas.height;
      const tctx = tmp.getContext("2d");
      tctx.drawImage(image, 0, 0);
      overlays.forEach(o => {
        tctx.save();
        tctx.translate(o.x, o.y);
        tctx.rotate(o.angle);
        tctx.drawImage(overlayImage, -o.w/2, -o.h/2, o.w, o.h);
        tctx.restore();
      });
      return tmp.toDataURL("image/png");
    }

    window.onload = init;
  </script>

  <footer style="width:100%;">
    <hr>
    <p style="text-align:center;color:#777;">
      © 2025 PotatoTimeKun<br>
      常識の範囲内でお使いください。<br>
      MIT Licence
    </p>
  </footer>
</body>
</html>
